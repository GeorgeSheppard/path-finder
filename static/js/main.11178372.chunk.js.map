{"version":3,"sources":["Canvas/canvas.tsx","Utilities/utilities.js","Algorithms/base.js","Hexagon/hexagon.tsx","HexagonGrid/hexagonGrid.tsx","Toolbar/Context.ts","HexagonGrid/hexagonGridManager.tsx","Toolbar/toolbar.tsx","App.js","serviceWorker.js","index.js"],"names":["Canvas","props","state","ref","createRef","windowSize","height","width","this","setState","current","offsetHeight","offsetWidth","nextProps","nextState","currentWindow","nextWindow","style","overflow","backgroundColor","Component","siderWidth","setGridSize","React","twoDToOneDCoord","coord","sizeY","StyledHexagon","styled","div","middleWidth","middleHeight","borderStyle","middleBorderWidth","topBotDiameter","left","topBot","topBotBorderWidth","borderWidth","Hexagon","limitedState","wall","goal","start","handleChange","event","oldType","button","newType","selected","newHexagonStates","hexagonStates","removeOldState","addNewState","setHexagonStates","handleHover","mouseDown","type","filter","a","b","Array","isArray","length","every","val","index","push","css","typeToStyling","onClick","onMouseOver","onMouseDown","HexagonGrid","pixelsCoords","gridProps","hexagonCssProps","useState","setMouseDown","handleMouseDown","parsedHexagonStates","sizeX","hexagonStartingStates","fill","Object","entries","forEach","row","key","onMouseUp","coords","map","i","x","y","transform","offsetX","offsetY","HexagonGridPropertiesContext","createContext","value","HexagonGridManager","spacing","horizontalSpacing","verticalSpacing","Math","sqrt","coordToPixels","pixelsX","pixelsY","floor","j","createGrid","margin","hexagonStylingProps","Consumer","SubMenu","Menu","Sider","Layout","Toolbar","gridSize","setSelected","algorithm","setAlgorithm","className","mode","icon","UserOutlined","title","color","undefined","Item","LaptopOutlined","NotificationOutlined","display","justifyContent","alignItems","marginTop","shape","size","disabled","console","log","Provider","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.11178372.chunk.js","sourcesContent":["import React, { createRef } from \"react\";\r\nimport { Setter } from \"../types/dtypes\";\r\n\r\ntype CanvasProps = {\r\n  Component: Function;\r\n  [key: string]: any;\r\n  setGridSize: Setter;\r\n};\r\n\r\nexport type WindowSize = {\r\n  height: number;\r\n  width: number;\r\n};\r\n\r\ntype Ref = React.RefObject<HTMLDivElement>;\r\n\r\ntype CanvasState = {\r\n  ref: Ref;\r\n  windowSize: {\r\n    height: number;\r\n    width: number;\r\n  };\r\n};\r\n\r\n/**\r\n * Helper component that sends the size of the window it fills to the child\r\n * component\r\n * @param {object} props the child component, and any props to pass to the child\r\n * component\r\n */\r\nclass Canvas extends React.Component<CanvasProps, CanvasState> {\r\n  constructor(props: CanvasProps) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      ref: createRef(),\r\n      windowSize: {\r\n        height: 0,\r\n        width: 0,\r\n      },\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const ref: Ref = this.state.ref;\r\n    this.setState({\r\n      windowSize: {\r\n        height: ref.current?.offsetHeight ?? 0,\r\n        width: ref.current?.offsetWidth ?? 0,\r\n      },\r\n    });\r\n  }\r\n\r\n  shouldComponentUpdate(nextProps: CanvasProps, nextState: CanvasState) {\r\n    const currentWindow = this.state.windowSize;\r\n    const nextWindow = nextState.windowSize;\r\n    return (\r\n      currentWindow.height !== nextWindow.height ||\r\n      currentWindow.width !== nextWindow.width\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const canvasStyle = {\r\n      overflow: \"hidden\",\r\n      height: \"100vh\",\r\n      width: \"100vw\",\r\n      backgroundColor: \"#dddddd\",\r\n    };\r\n\r\n    return (\r\n      <div ref={this.state.ref} style={canvasStyle}>\r\n        <this.props.Component\r\n          {...{\r\n            windowSize: this.state.windowSize,\r\n            siderWidth: this.props.siderWidth,\r\n            setGridSize: this.props.setGridSize,\r\n          }}\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Canvas;\r\n","export function arrayEquals(a, b) {\r\n  return Array.isArray(a) &&\r\n    Array.isArray(b) &&\r\n    a.length === b.length &&\r\n    a.every((val, index) => val === b[index]);\r\n};\r\n\r\nexport function twoDToOneDCoord(coord, sizeY) {\r\n  return coord[0] * sizeY + coord[1];\r\n}","import { twoDToOneDCoord } from \"../Utilities/utilities\"\r\n\r\nexport const router = (algorithm, hexagonStates, sizeX, sizeY) => {\r\n  console.log('router called');\r\n  console.log(algorithm, hexagonStates, sizeX, sizeY);\r\n}\r\n\r\nexport const neighbours = (coord, sizeX, sizeY) => {\r\n  const [x, y] = coord;\r\n\r\n  let neighboursRelative;\r\n  if (y % 2 === 0) {\r\n    neighboursRelative = [[-1, -1], [-1, 0], [0, 1], [1, 0], [1, -1], [0, -1]];\r\n  } else {\r\n    neighboursRelative = [[-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [0, -1]]\r\n  }\r\n\r\n  return neighboursRelative.map((coord) => [coord[0] + x, coord[1] + y]).filter((coord) => {\r\n    const [x, y] = coord;\r\n    return (x >= 0 && x < sizeX) && (y >= 0 && y < sizeY)\r\n  })\r\n}\r\n\r\nexport const pathFinder = (algorithm, hexagonStates, sizeX, sizeY) => {\r\n  // grid1D is a 1d array containing the type of each of the hexagon states\r\n  const grid1D = new Array(sizeX * sizeY).fill(0)\r\n\r\n  // shortestPathGrid will be a 1d array that contains at coordinate x, the coordinate of the \r\n  // previous coordinate on the shortest path to coordinate x\r\n  // e.g. [-1, -1, [5, 3], [0, 2], -1]\r\n  const shortestPathGrid = new Array(sizeX * sizeY).fill(-1)\r\n\r\n  for (const wallCoord in hexagonStates.wall) {\r\n    grid1D[twoDToOneDCoord(wallCoord)] = -1\r\n  }\r\n\r\n  const goal = hexagonStates.goal[0];\r\n  const start = hexagonStates.start[0];\r\n\r\n  const goal1DCoord = twoDToOneDCoord(goal);\r\n  grid1D[goal1DCoord] = 1;\r\n  const start1DCoord = twoDToOneDCoord(start);\r\n  shortestPathGrid[start1DCoord] = start;\r\n\r\n  const [shortestPath, pathGrid] = algorithm(grid1D, shortestPathGrid, start, goal, (coord) => neighbours(coord, sizeX, sizeY));\r\n  console.log(shortestPath);\r\n  console.log(pathGrid);\r\n}","import React from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { Coord, HexagonStates, HexagonTypes, Setter } from \"../types/dtypes\";\r\nimport { arrayEquals } from \"../Utilities/utilities\";\r\n\r\nexport interface FixedHexagonStylingProps {\r\n  middleWidth: number;\r\n  middleHeight: number;\r\n  topBotDiameter: number;\r\n  margin: number;\r\n  topBotBorderWidth: number;\r\n  middleBorderWidth: number;\r\n  left: number;\r\n  topBot: number;\r\n}\r\n\r\nexport interface StyledHexagonProps extends FixedHexagonStylingProps {\r\n  backgroundColor: string;\r\n}\r\n// TODO: Cannot find a way to set multiple properties to the same value,\r\n// would be useful for setting border-left and border-right at the same time,\r\n// have tried using , like with &:before &:after but that doesn't work\r\n/**\r\n * A CSS hexagon, with configurable size, colours, and border\r\n */\r\nconst StyledHexagon = styled.div`\r\n  position: absolute;\r\n  width: ${(props: StyledHexagonProps) => `${props.middleWidth}px`};\r\n  height: ${(props: StyledHexagonProps) => `${props.middleHeight}px`};\r\n  background-color: ${(props: StyledHexagonProps) => props.backgroundColor};\r\n  border-left: ${(props: StyledHexagonProps) =>\r\n    borderStyle(props.middleBorderWidth)};\r\n  border-right: ${(props: StyledHexagonProps) =>\r\n    borderStyle(props.middleBorderWidth)};\r\n  &:before,\r\n  &:after {\r\n    content: \"\";\r\n    position: absolute;\r\n    z-index: 1;\r\n    width: ${(props: StyledHexagonProps) => `${props.topBotDiameter}px`};\r\n    height: ${(props: StyledHexagonProps) => `${props.topBotDiameter}px`};\r\n    transform: scaleY(0.5774) rotate(-45deg);\r\n    background-color: inherit;\r\n    left: ${(props: StyledHexagonProps) => `${props.left}px`};\r\n  }\r\n  &:before {\r\n    top: ${(props: StyledHexagonProps) => `${props.topBot}px`};\r\n    border-top: ${(props: StyledHexagonProps) =>\r\n      borderStyle(props.topBotBorderWidth)};\r\n    border-right: ${(props: StyledHexagonProps) =>\r\n      borderStyle(props.topBotBorderWidth)};\r\n  }\r\n  &:after {\r\n    bottom: ${(props: StyledHexagonProps) => `${props.topBot}px`};\r\n    border-bottom: ${(props: StyledHexagonProps) =>\r\n      borderStyle(props.topBotBorderWidth)};\r\n    border-left: ${(props: StyledHexagonProps) =>\r\n      borderStyle(props.topBotBorderWidth)};\r\n  }\r\n`;\r\n\r\n// Used in the CSS hexagon above\r\nconst borderStyle = (borderWidth: number) => `solid ${borderWidth}px #333333`;\r\n\r\n/**\r\n * Returns an object containing all parameters that physically specify a hexagon\r\n * @param {float} width: the distance between two opposite sides of the hexagon, not\r\n * including the border width\r\n * @param {float} borderWidth: the width of the border, from the outer of the hexagon\r\n * to the outer of the border\r\n */\r\nexport const hexagonStylingProps = ({\r\n  width,\r\n  borderWidth,\r\n}: any): FixedHexagonStylingProps => {\r\n  return {\r\n    middleWidth: width,\r\n    middleHeight: (Math.sqrt(3) / 3) * width,\r\n    topBotDiameter: width / Math.sqrt(2),\r\n    margin: (width * Math.sqrt(3)) / 6,\r\n    topBotBorderWidth: borderWidth * Math.sqrt(2),\r\n    middleBorderWidth: borderWidth,\r\n    left: -borderWidth - width / (Math.sqrt(2) * 2) + width / 2,\r\n    topBot: -width / (Math.sqrt(2) * 2),\r\n  };\r\n};\r\n\r\n/**\r\n * Converts the type of a hexagon into the colour it's background should be\r\n * @param type: the state of the hexagon, currently 'space', 'wall', 'goal', or 'start'\r\n */\r\nconst typeToStyling = (type: string) => {\r\n  let backgroundColor = \"#64C7CC\";\r\n  switch (type) {\r\n    case \"space\":\r\n      break;\r\n    case \"wall\":\r\n      backgroundColor = \"#000000\";\r\n      break;\r\n    case \"goal\":\r\n      backgroundColor = \"#00ff00\";\r\n      break;\r\n    case \"start\":\r\n      backgroundColor = \"#ff0000\";\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n  return backgroundColor;\r\n};\r\n\r\nexport interface HexagonProps {\r\n  type: HexagonTypes;\r\n  selected: HexagonTypes;\r\n  mouseDown: boolean;\r\n  css: any;\r\n  style: any;\r\n  setHexagonStates: Setter;\r\n  hexagonStates: HexagonStates;\r\n  coord: Coord;\r\n}\r\n\r\n/**\r\n * A general hexagon class, used to build up the hexagon grid.\r\n * The logic behind it is as follows:\r\n * - The type the hexagon should be (e.g. 'wall', 'start' etc) is passed in on props and the hexagon renders\r\n * - When the hexagon is clicked OR dragged over with a new type selected in the toolbar, the updated state is sent\r\n * to the overall store for the grid\r\n * - This new grid state is then passed down to each hexagon, NOTE: some states are limited\r\n * (e.g. can only be one 'start' state), so if a new 'start' state is created the old one is removed\r\n * - When each hexagon receives it's new type (according to the grid store), it updates only if it's current type\r\n * doesn't match the new one\r\n */\r\nclass Hexagon extends React.Component<HexagonProps> {\r\n  /**\r\n   * A mapping from state types to whether that state is limited in it's numbers or not\r\n   * there can only be one goal and one start point, but many walls\r\n   * NOTE: 'space' is not mapped here as it should be checked seperately and space locations\r\n   * are not stored, a grid can be\r\n   * fully specified using it's dimensions, and the location of the remaining hexagon types\r\n   */\r\n  limitedState = {\r\n    wall: false,\r\n    goal: true,\r\n    start: true,\r\n  };\r\n\r\n  /**\r\n   * Decides whether the component needs to rerender, based on the set of props that have just\r\n   * been passed in\r\n   * @param {object} nextProps: the new properties passed into the hexagon\r\n   */\r\n  shouldComponentUpdate(nextProps: HexagonProps) {\r\n    return nextProps.type !== this.props.type;\r\n  }\r\n\r\n  /**\r\n   * Updates the hexagonStates object that specifies all the states of the hexagonGrid, by removing\r\n   * the old state of this hexagon from it\r\n   * @param {string} oldType: 'space' | 'wall' | 'goal' | 'start'\r\n   * @param {object} newHexagonStates: a copy of the hexagonStates object to modify\r\n   * @returns newHexagonStates: with the old state of this hexagon removed\r\n   */\r\n  removeOldState(oldType: HexagonTypes, newHexagonStates: HexagonStates) {\r\n    if (oldType !== \"space\") {\r\n      if (this.limitedState[oldType]) {\r\n        newHexagonStates[oldType] = [];\r\n      } else {\r\n        newHexagonStates[oldType] = newHexagonStates[oldType].filter(\r\n          (coord) => !arrayEquals(coord, this.props.coord)\r\n        );\r\n      }\r\n    }\r\n    return newHexagonStates;\r\n  }\r\n\r\n  /**\r\n   * Updates the hexagonStates object that specifies all the states of the hexagonGrid, by adding the\r\n   * new state of this hexagon to it\r\n   * @param {string} newType: 'space' | 'wall' | 'goal' | 'start'\r\n   * @param {object} newHexagonStates: a copy of the hexagonStates object to modify\r\n   * @returns newHexagonStates: with the new state of this hexagon added to it\r\n   */\r\n  addNewState(newType: HexagonTypes, newHexagonStates: HexagonStates) {\r\n    if (newType !== \"space\") {\r\n      if (this.limitedState[newType]) {\r\n        newHexagonStates[newType] = [this.props.coord];\r\n      } else {\r\n        newHexagonStates[newType].push(this.props.coord);\r\n      }\r\n    }\r\n    return newHexagonStates;\r\n  }\r\n\r\n  /**\r\n   * Utilises the addNewState and removeOldState methods to update the hexagonGridState,\r\n   * which subsequently gets passed down as a new prop\r\n   * @param {object} event: event object from e.g. a click\r\n   * @param {string} oldType: 'space' | 'wall' | 'goal' | 'start'\r\n   */\r\n  handleChange = (\r\n    event: React.MouseEvent<HTMLElement>,\r\n    oldType: HexagonTypes\r\n  ) => {\r\n    if (event.button === 0) {\r\n      const newType = this.props.selected;\r\n\r\n      if (newType !== oldType) {\r\n        let newHexagonStates = { ...this.props.hexagonStates };\r\n\r\n        newHexagonStates = this.removeOldState(oldType, newHexagonStates);\r\n        newHexagonStates = this.addNewState(newType, newHexagonStates);\r\n\r\n        this.props.setHexagonStates(newHexagonStates);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Triggered when the mouse hovers over the top of the hexagon\r\n   * @param {object} event: onMouseOver event\r\n   * @param {string} oldType: 'space' | 'wall' | 'goal' | 'start'\r\n   */\r\n  handleHover = (\r\n    event: React.MouseEvent<HTMLElement>,\r\n    oldType: HexagonTypes\r\n  ) => {\r\n    if (this.props.mouseDown) {\r\n      this.handleChange(event, oldType);\r\n    }\r\n  };\r\n\r\n  render() {\r\n    const { type, css, style } = this.props as HexagonProps;\r\n    const backgroundColor = typeToStyling(type);\r\n\r\n    // NOTE: Type is stored in the functions instead of on this.state\r\n    return (\r\n      <StyledHexagon\r\n        {...{ ...css, backgroundColor }}\r\n        style={style}\r\n        onClick={(event: React.MouseEvent<HTMLElement>) =>\r\n          this.handleChange(event, type)\r\n        }\r\n        onMouseOver={(event: React.MouseEvent<HTMLElement>) =>\r\n          this.handleHover(event, type)\r\n        }\r\n        onMouseDown={(event: React.MouseEvent<HTMLElement>) =>\r\n          this.handleChange(event, type)\r\n        }\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nexport default Hexagon;\r\n","import React, { useState } from \"react\";\r\nimport {\r\n  HexagonStates,\r\n  HexagonTypes,\r\n  Setter,\r\n  Coord,\r\n  Coords,\r\n} from \"../types/dtypes\";\r\nimport { CreateGridReturn } from \"./hexagonGridManager\";\r\nimport { twoDToOneDCoord } from \"../Utilities/utilities\";\r\nimport Hexagon, { FixedHexagonStylingProps } from \"../Hexagon/hexagon\";\r\n\r\ntype HexagonGridProps = {\r\n  hexagonStates: HexagonStates;\r\n  setHexagonStates: Setter;\r\n  selected: HexagonTypes;\r\n  pixelsCoords: Coords;\r\n  gridProps: CreateGridReturn;\r\n  hexagonCssProps: FixedHexagonStylingProps;\r\n};\r\n\r\n// TODO: This is currently the component restricting performance, as each time hexagonStates changes (often with just one change)\r\n// the whole component rerenders, this performance is only a problem with smaller hexagons so leaving this for now, but could\r\n// later convert to a class component and use state to store things to reduce calculations (looking at hexagonStartingStates),\r\n// could also just look for the difference between old hexagonStates and new ones so that hexagonStartingStates just needs to be\r\n// run once for that specific hexagon\r\nconst HexagonGrid = (props: HexagonGridProps) => {\r\n  const {\r\n    hexagonStates,\r\n    setHexagonStates,\r\n    selected,\r\n    pixelsCoords,\r\n    gridProps,\r\n    hexagonCssProps,\r\n  } = props;\r\n\r\n  const [mouseDown, setMouseDown] = useState(false);\r\n\r\n  const handleMouseDown = (state: boolean): Setter => {\r\n    return (event: React.MouseEvent<HTMLDivElement>) => {\r\n      if (event.button === 0) {\r\n        setMouseDown(state);\r\n      }\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Maps a grid specification of the form\r\n   * {\r\n   * 'wall': [[2, 0], [3, 5]],\r\n   * 'goal': [[1, 2]],\r\n   * 'start': [[3,  6]]\r\n   * }\r\n   * into an array that has the type of each individual hexagon on the grid\r\n   * @param {object} gridProps output of the createGrid function\r\n   * @param {*} hexagonStates grid specification\r\n   */\r\n  const hexagonStartingStates = (\r\n    gridProps: CreateGridReturn | undefined,\r\n    hexagonStates: HexagonStates\r\n  ) => {\r\n    if (gridProps) {\r\n      const { sizeX, sizeY } = gridProps;\r\n      const hexagonStartingStates = new Array(sizeX * sizeY).fill(\"space\");\r\n\r\n      Object.entries(hexagonStates).forEach((row) => {\r\n        const key = row[0];\r\n        row[1].forEach((coord: Coord) => {\r\n          hexagonStartingStates[twoDToOneDCoord(coord, sizeY)] = key;\r\n        });\r\n      });\r\n\r\n      return hexagonStartingStates;\r\n    }\r\n  };\r\n\r\n  const parsedHexagonStates = hexagonStartingStates(gridProps, hexagonStates);\r\n\r\n  return (\r\n    <div onMouseDown={handleMouseDown(true)} onMouseUp={handleMouseDown(false)}>\r\n      {gridProps &&\r\n        parsedHexagonStates &&\r\n        gridProps.coords.map((coord, i) => {\r\n          const [x, y] = coord;\r\n\r\n          const transform = pixelsCoords[i];\r\n\r\n          const { offsetX, offsetY } = gridProps;\r\n\r\n          // maps hexagons to correct coordinate and centre the entire grid\r\n          const style = {\r\n            transform: `translate(${transform[0] + offsetX}px, ${\r\n              transform[1] + offsetY\r\n            }px)`,\r\n          };\r\n\r\n          return (\r\n            <Hexagon\r\n              key={`${x}:${y}`}\r\n              style={style}\r\n              css={hexagonCssProps}\r\n              {...{\r\n                type: parsedHexagonStates[i],\r\n                coord,\r\n                selected,\r\n                mouseDown,\r\n                hexagonStates,\r\n                setHexagonStates,\r\n              }}\r\n            />\r\n          );\r\n        })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default HexagonGrid;\r\n","import React from \"react\";\r\nimport { HexagonStates, Setter, HexagonTypes } from '../types/dtypes';\r\n\r\nexport type GridPropertiesContext = {\r\n  hexagonStates: HexagonStates;\r\n  setHexagonStates: Setter;\r\n  selected: HexagonTypes;\r\n};\r\n\r\nexport const HexagonGridPropertiesContext = React.createContext<\r\n  GridPropertiesContext\r\n>({\r\n  hexagonStates: {\r\n    goal: [],\r\n    start: [],\r\n    wall: [],\r\n  } as HexagonStates,\r\n  setHexagonStates: (value: HexagonStates): void => {},\r\n  selected: \"wall\",\r\n});","import React from \"react\";\r\nimport { WindowSize } from \"../Canvas/canvas\";\r\nimport HexagonGrid from \"./hexagonGrid\";\r\nimport { Coord, Coords, Setter } from \"../types/dtypes\";\r\nimport { hexagonStylingProps } from \"../Hexagon/hexagon\";\r\nimport {\r\n  HexagonGridPropertiesContext,\r\n  GridPropertiesContext,\r\n} from \"../Toolbar/Context\";\r\n\r\ntype HexagonGridManagerProps = {\r\n  width?: number;\r\n  borderWidth?: number;\r\n  spacing?: number;\r\n  siderWidth: number;\r\n  windowSize: WindowSize;\r\n  setGridSize: Setter;\r\n};\r\n\r\nexport type CreateGridReturn = {\r\n  coords: Coords;\r\n  offsetX: number;\r\n  offsetY: number;\r\n  sizeX: number;\r\n  sizeY: number;\r\n};\r\n\r\n/**\r\n * Wrapper component to manage overarching state for the hexagon grid, such\r\n * that each change of the HexagonStates don't cause a recalculation of\r\n * static properties\r\n */\r\nconst HexagonGridManager = (props: HexagonGridManagerProps) => {\r\n  const {\r\n    width = 50,\r\n    borderWidth = 5,\r\n    spacing = 5,\r\n    siderWidth,\r\n    windowSize,\r\n    setGridSize,\r\n  } = props;\r\n\r\n  const horizontalSpacing = width + spacing;\r\n  const verticalSpacing = (Math.sqrt(3) / 2) * width + spacing / 2;\r\n\r\n  /**\r\n   * Given the size of the window to display the grid, calculates the list of possible\r\n   * coordinates, the available border width for the grid, and the dimensions of the grid\r\n   * @param {number} windowSize\r\n   */\r\n  const createGrid = (\r\n    windowSize: WindowSize,\r\n    siderWidth: number\r\n  ): CreateGridReturn | undefined => {\r\n    if (windowSize.height !== 0 && windowSize.width !== 0) {\r\n      const sizeX = Math.floor(\r\n        (windowSize.width - siderWidth - horizontalSpacing / 2) /\r\n          horizontalSpacing\r\n      );\r\n\r\n      const sizeY = Math.floor(\r\n        (windowSize.height - (Math.sqrt(3) / 3) * width) / verticalSpacing\r\n      );\r\n\r\n      const offsetX =\r\n        (windowSize.width - siderWidth - (sizeX + 0.5) * horizontalSpacing) / 2;\r\n      const offsetY = (windowSize.height - (sizeY + 0.5) * verticalSpacing) / 2;\r\n\r\n      const coords: Coords = [];\r\n\r\n      for (let i = 0; i < sizeX; i++) {\r\n        for (let j = 0; j < sizeY; j++) {\r\n          const coord: Coord = [i, j];\r\n          coords.push(coord);\r\n        }\r\n      }\r\n\r\n      return { coords, offsetX, offsetY, sizeX, sizeY };\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Converts a coordinate into a pixel coordinate\r\n   * @param {number} x\r\n   * @param {number} y\r\n   */\r\n  const coordToPixels = (x: number, y: number): Coord => {\r\n    let pixelsX = horizontalSpacing * x;\r\n    const pixelsY = verticalSpacing * y + (Math.sqrt(3) / 6) * width;\r\n    if (y % 2 === 1) {\r\n      pixelsX += horizontalSpacing / 2;\r\n    }\r\n\r\n    return [pixelsX, pixelsY];\r\n  };\r\n\r\n  const gridProps = createGrid(windowSize, siderWidth);\r\n\r\n  if (gridProps) {\r\n    setGridSize({\r\n      x: gridProps?.sizeX,\r\n      y: gridProps?.sizeY,\r\n    });\r\n    // Calculate the styling props once and then use it for all hexagons\r\n    const hexagonCssProps = hexagonStylingProps({\r\n      width,\r\n      borderWidth,\r\n    });\r\n\r\n    const pixelsCoords: Coords = gridProps?.coords.map((coord: Coord) =>\r\n      coordToPixels(...coord)\r\n    );\r\n    return (\r\n      <HexagonGridPropertiesContext.Consumer>\r\n        {(value: GridPropertiesContext) => (\r\n          <HexagonGrid\r\n            {...{ ...value, hexagonCssProps, pixelsCoords, gridProps }}\r\n          />\r\n        )}\r\n      </HexagonGridPropertiesContext.Consumer>\r\n    );\r\n  } else {\r\n    return null;\r\n  }\r\n};\r\n\r\nexport default HexagonGridManager;\r\n","import React, { useState } from \"react\";\r\nimport { Layout, Menu, Button } from \"antd\";\r\nimport {\r\n  UserOutlined,\r\n  LaptopOutlined,\r\n  NotificationOutlined,\r\n} from \"@ant-design/icons\";\r\nimport \"./toolbar.css\";\r\nimport \"antd/dist/antd.css\";\r\nimport Canvas from \"../Canvas/canvas\";\r\nimport { router } from \"../Algorithms/base\";\r\nimport { HexagonTypes, HexagonStates } from \"../types/dtypes\";\r\nimport HexagonGridManager from \"../HexagonGrid/hexagonGridManager\";\r\nimport { HexagonGridPropertiesContext } from \"./Context\";\r\n\r\nconst { SubMenu } = Menu;\r\nconst { Sider } = Layout;\r\n\r\nexport type GridSize = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\nconst Toolbar = () => {\r\n  const [hexagonStates, setHexagonStates] = useState<HexagonStates>({\r\n    goal: [[7, 3]],\r\n    start: [[4, 5]],\r\n    wall: [\r\n      [8, 2],\r\n      [5, 4],\r\n      [6, 7],\r\n      [5, 5],\r\n      [6, 4],\r\n      [7, 4],\r\n      [6, 5],\r\n      [7, 6],\r\n      [4, 3],\r\n      [4, 2],\r\n      [3, 2],\r\n      [7, 7],\r\n      [8, 6],\r\n      [8, 5],\r\n    ],\r\n  });\r\n\r\n  const [gridSize, setGridSize] = useState<GridSize>({\r\n    x: 0,\r\n    y: 0,\r\n  });\r\n\r\n  const [selected, setSelected] = useState<HexagonTypes>(\"wall\");\r\n  const siderWidth: number = 200;\r\n\r\n  const [algorithm, setAlgorithm] = useState(\"\");\r\n\r\n  return (\r\n    <Layout>\r\n      <Layout>\r\n        <Sider width={siderWidth} className=\"site-layout-background\">\r\n          <Menu mode=\"inline\" style={{ height: \"100vh\" }}>\r\n            <SubMenu\r\n              key=\"sub1\"\r\n              icon={<UserOutlined />}\r\n              title=\"Required\"\r\n              style={{\r\n                color:\r\n                  hexagonStates.start.length === 0 ||\r\n                  hexagonStates.goal.length === 0\r\n                    ? \"red\"\r\n                    : undefined,\r\n              }}\r\n            >\r\n              <Menu.Item\r\n                key=\"1\"\r\n                onClick={() => setSelected(\"start\")}\r\n                style={{\r\n                  color: hexagonStates.start.length === 0 ? \"red\" : undefined,\r\n                }}\r\n              >\r\n                Start\r\n              </Menu.Item>\r\n              <Menu.Item\r\n                key=\"2\"\r\n                onClick={() => setSelected(\"goal\")}\r\n                style={{\r\n                  color: hexagonStates.goal.length === 0 ? \"red\" : undefined,\r\n                }}\r\n              >\r\n                Goal\r\n              </Menu.Item>\r\n            </SubMenu>\r\n            <SubMenu key=\"sub2\" icon={<LaptopOutlined />} title=\"Optional\">\r\n              <Menu.Item key=\"3\" onClick={() => setSelected(\"wall\")}>\r\n                Wall\r\n              </Menu.Item>\r\n              <Menu.Item key=\"4\" onClick={() => setSelected(\"space\")}>\r\n                Space\r\n              </Menu.Item>\r\n            </SubMenu>\r\n            <SubMenu\r\n              key=\"sub3\"\r\n              icon={<NotificationOutlined />}\r\n              title=\"Algorithm\"\r\n              style={{\r\n                color: algorithm.length === 0 ? \"red\" : undefined,\r\n              }}\r\n            >\r\n              <Menu.Item key=\"9\" onClick={() => setAlgorithm(\"dijkstra\")}>\r\n                Dijkstra\r\n              </Menu.Item>\r\n              <Menu.Item key=\"10\" onClick={() => setAlgorithm(\"greedy\")}>\r\n                Greedy\r\n              </Menu.Item>\r\n            </SubMenu>\r\n            <div\r\n              style={{\r\n                display: \"flex\",\r\n                justifyContent: \"center\",\r\n                alignItems: \"center\",\r\n                marginTop: \"20px\",\r\n              }}\r\n            >\r\n              <Button\r\n                type=\"primary\"\r\n                shape=\"round\"\r\n                size={\"large\"}\r\n                disabled={\r\n                  algorithm.length === 0 ||\r\n                  hexagonStates.goal.length === 0 ||\r\n                  hexagonStates.start.length === 0\r\n                }\r\n                onClick={() =>\r\n                  // TODO: To access gridSize need hexagonGrid not to re-render\r\n                  // whenever props the toolbar re-renders, therefore turn hexagonGrid\r\n                  // into class component and add shouldComponentUpdate function\r\n                  router(algorithm, hexagonStates, gridSize.x, gridSize.y)\r\n                }\r\n              >\r\n                Visualise\r\n              </Button>\r\n            </div>\r\n          </Menu>\r\n        </Sider>\r\n        <HexagonGridPropertiesContext.Provider\r\n          value={{ hexagonStates, setHexagonStates, selected }}\r\n        >\r\n          <Canvas\r\n            Component={HexagonGridManager}\r\n            {...{\r\n              siderWidth,\r\n              setGridSize,\r\n            }}\r\n          />\r\n        </HexagonGridPropertiesContext.Provider>\r\n      </Layout>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default Toolbar;\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport Toolbar from \"./Toolbar/toolbar\";\r\n\r\nfunction App() {\r\n  return <Toolbar />;\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}